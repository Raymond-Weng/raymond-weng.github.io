---
title: 補一個之前的Daily題解：Leetcode 2598
date: 2025-10-19 07:50:00 +0800
categories: [Code, LeetCode]
tags: [leetcode, lc_daily]     # TAG names should always be lowercase
description: 聊聊10/16的Leetcode daily題目
---

10/16號的Daily Question剛好寫的不差就放上來，可以先看[題目](https://leetcode.com/problems/smallest-missing-non-negative-integer-after-operations/)  
這題想法重點是這句話

> applying the mentioned operation **any number of times**

可以像是化學上如果遇到極小量反應的時候全部反應到左邊之後再向右反應  
.  
不具體？  
換個說法來說像是先用無數次機會變成0~(value-1)，一個循環裡面加一個value就可以檢查。  
記錄成0~(value)的數量，一個循環用掉一個，**最小的會先被用完，所以要找最小值**，再來判斷總共用幾個

[Leetcode 2598](https://leetcode.com/problems/smallest-missing-non-negative-integer-after-operations/)(Medium) AC  
Time: 2ms beats 89.87%  
Memory: 119.95MB beats 94.55%
```c++
class Solution {
public:
    int findSmallestInteger(vector<int>& nums, int value) {
        ios::sync_with_stdio(0);
        cin.tie(0);
        cout.tie(0);
        int* cnt = new int[value];
        for(int i = 0; i < value; i++){
            cnt[i] = 0; // 初始化
        }
        for(int i = 0; i < nums.size(); i++){
            cnt[((nums[i]%value)+value)%value]++; // 先變小，+value要處理負數
        }
        int m = cnt[0], p = 0;
        for(int i = 1; i < value; i++){
            if(cnt[i] < m){
                p = i;
                m = cnt[i];
            }
        }
        return m*value+p;
    }
};
```
